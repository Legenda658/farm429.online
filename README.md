# Документация системы "ФитоДомик"

## О системе

"ФитоДомик" - это комплексная веб-система для управления умной фермой, разработанная для автоматизации процессов выращивания растений в домашних условиях. Система предоставляет интерфейс для мониторинга и контроля показателей окружающей среды, управления устройствами автоматизации и ведения журнала растениеводства.

### Ключевые возможности

- **Мониторинг показателей в реальном времени**: температура, влажность воздуха, влажность почвы, уровень освещенности
- **Автоматизированное управление**: включение/выключение освещения, открытие/закрытие штор
- **Предустановленные режимы выращивания**: оптимизированные под различные типы растений
- **Уведомления и оповещения**: мгновенные сообщения о критичных событиях через Telegram
- **Календарь посадок**: планирование и ведение записей о растениях
- **Мобильная адаптивность**: полноценная работа на любых устройствах
- **Защита данных**: многоуровневая система безопасности
- **Поддержка светлой и темной тем**: адаптация интерфейса к предпочтениям пользователя

### Технологический стек

- **Серверная часть**: PHP 7.4+, MySQL 8.0
- **Клиентская часть**: HTML5, CSS3, JavaScript (ES6+)
- **Интеграция**: Telegram Bot API 
- **Безопасность**: PDO, подготовленные запросы, CSP, защита от XSS и CSRF
- **Другие технологии**: AJAX, Chart.js, localStorage

## Содержание

1. [Общая структура проекта](#общая-структура-проекта)
2. [Файлы конфигурации](#файлы-конфигурации)
3. [Компоненты безопасности](#компоненты-безопасности)
4. [Система аутентификации](#система-аутентификации)
5. [API и взаимодействие с устройствами](#api-и-взаимодействие-с-устройствами)
6. [Основные страницы и компоненты](#основные-страницы-и-компоненты)
7. [SEO-оптимизация](#seo-оптимизация)
8. [Система темизации](#система-темизации)
9. [Система логирования](#система-логирования)
10. [Структура базы данных](#структура-базы-данных)

## Общая структура проекта

Проект организован по модульному принципу с четким разделением ответственности между компонентами. Такая архитектура обеспечивает высокую масштабируемость и упрощает поддержку и расширение функциональности.

### Файловая структура

```
/
├── api/                     # API эндпоинты для взаимодействия с устройствами
│   ├── check_verification.php     # Проверка статуса верификации пользователя
│   ├── get-curtains-state.php     # Получение состояния штор
│   ├── get-farm-analysis.php      # Аналитические данные по ферме
│   ├── get-farm-status.php        # Текущее состояние фермы
│   ├── get-lamp-state.php         # Состояние освещения
│   ├── get-max-sensor-id.php      # Получение максимального ID датчика
│   ├── get-sensor-data.php        # Чтение показаний датчиков
│   ├── get-thresholds.php         # Получение пороговых значений
│   ├── save-humidity.php          # Сохранение данных о влажности
│   ├── save-lighting.php          # Настройки освещения
│   ├── save-limits.php            # Сохранение пороговых значений
│   ├── save-preset-mode.php       # Сохранение пресета выращивания
│   ├── save-sensor-data.php       # Запись показаний датчиков
│   ├── save-temperature.php       # Сохранение температурных данных
│   ├── set-curtains-state.php     # Управление шторами
│   ├── telegram_webhook.php       # Обработчик уведомлений от Telegram
│   ├── toggle-curtains.php        # Переключение состояния штор
│   ├── toggle-lamp.php            # Переключение освещения
│   └── update-event-log.php       # Обновление журнала событий
│
├── authentication/          # Система авторизации и регистрации
│   ├── js/                       # JavaScript файлы для аутентификации
│   │   └── theme.js              # Управление темой в интерфейсе авторизации
│   ├── login.php                 # Страница входа в систему
│   ├── logout.php                # Обработчик выхода из системы
│   ├── profile.php               # Профиль пользователя
│   ├── register.php              # Регистрация нового пользователя
│   ├── settings.php              # Настройки пользовательского аккаунта
│   └── telegram_verify.php       # Верификация через Telegram
│
├── components/              # Модульные компоненты главной страницы
│   ├── alarm-thresholds.php      # Настройка пороговых значений
│   ├── event-log.php             # Журнал событий системы
│   ├── farm-graphs.php           # Графики показателей
│   ├── farm-settings.php         # Панель управления фермой
│   ├── farm-status.php           # Текущий статус фермы
│   ├── planting-calendar.php     # Календарь посадок
│   └── preset-modes.php          # Управление режимами выращивания
│
├── config/                  # Файлы конфигурации
│   ├── database.php              # Настройки подключения к БД
│   ├── headers.php               # HTTP заголовки безопасности
│   ├── session.php               # Управление сессиями
│   └── telegram.php              # Настройки Telegram API
│
├── css/                     # CSS стили
│   ├── components/               # Стили для отдельных компонентов
│   └── styles.css                # Основной файл стилей
│
├── icon/                    # Иконки и фавиконы
│   ├── android-chrome-192x192.png
│   ├── android-chrome-512x512.png
│   ├── apple-touch-icon.png
│   ├── favicon-16x16.png
│   ├── favicon-32x32.png
│   ├── favicon.ico
│   ├── safari-pinned-tab.svg
│   └── site.webmanifest
│
├── js/                      # JavaScript файлы
│   ├── charts.js                 # Визуализация данных
│   ├── dashboard.js              # Логика панели управления
│   ├── farm-control.js           # Управление устройствами
│   ├── planting-calendar.js      # Функционал календаря посадок
│   ├── sensor-data.js            # Обработка данных датчиков
│   └── theme.js                  # Управление темой интерфейса
│
├── logs/                    # Логи работы приложения
│   ├── api_errors.log            # Ошибки API запросов
│   ├── telegram_webhook.log      # Логи Telegram взаимодействия
│   └── verification_log.txt      # Логи процесса верификации
│
├── photos/                  # Пользовательские фотографии
│   └── plants/                   # Фотографии растений пользователей
│
├── py/                      # Python скрипты
│   ├── data_analysis.py          # Анализ данных с датчиков
│   └── image_processing.py       # Обработка изображений растений
│
├── security/                # Компоненты безопасности
│   ├── css.php                   # Безопасная загрузка CSS
│   ├── headers.php               # Заголовки безопасности
│   ├── image.php                 # Безопасное отображение изображений
│   ├── js.php                    # Безопасная загрузка JavaScript
│   ├── manifest.php              # Защита манифеста
│   └── security_bootstrap.php    # Инициализация компонентов безопасности
│
├── uploads/                 # Пользовательские загрузки
│   ├── avatars/                  # Аватары пользователей
│   └── temp/                     # Временные файлы
│
├── .htaccess                # Настройки Apache
├── 404.php                  # Страница 404 ошибки
├── dashboard.php            # Панель управления
├── get_token.php            # Получение API токена
├── import-mode.php          # Импорт режимов
├── index.php                # Главная страница
├── robots.txt               # Инструкции для поисковых роботов
└── sitemap.xml              # Карта сайта
```

### Описание ключевых директорий

#### Директория /api/

Содержит все API-эндпоинты для взаимодействия с умной фермой и получения/сохранения данных. API-файлы организованы по функциональному принципу:

- **Сбор данных**: файлы с префиксом `get-` отвечают за получение информации
- **Управление**: файлы с префиксом `set-` и `toggle-` осуществляют управление устройствами
- **Хранение**: файлы с префиксом `save-` записывают данные в базу данных
- **Интеграция**: файлы связанные с внешними сервисами (например, `telegram_webhook.php`)

Все API эндпоинты проверяют авторизацию и права доступа, принимают данные в формате JSON или через POST-запросы, и возвращают результаты в формате JSON.

#### Директория /authentication/

Содержит все файлы, отвечающие за регистрацию, авторизацию и управление учетными записями пользователей:

- **register.php**: регистрация нового пользователя с валидацией данных
- **login.php**: авторизация существующего пользователя
- **telegram_verify.php**: дополнительная верификация через Telegram бота
- **profile.php**: просмотр и редактирование профиля пользователя
- **settings.php**: настройка параметров пользовательского аккаунта
- **logout.php**: выход из системы и уничтожение сессии

Все страницы аутентификации имеют единый стиль оформления и поддерживают переключение темы.

#### Директория /components/

Модульные компоненты, которые включаются на главной странице и в панели управления:

- **farm-status.php**: отображение текущего состояния фермы в реальном времени
- **farm-settings.php**: интерфейс для управления устройствами
- **farm-graphs.php**: графическое представление данных с датчиков
- **alarm-thresholds.php**: настройка пороговых значений для автоматизации
- **preset-modes.php**: создание, редактирование и активация готовых режимов
- **planting-calendar.php**: интерфейс для планирования и отслеживания активностей
- **event-log.php**: журнал событий системы с фильтрацией

Каждый компонент разработан как независимый модуль, который может быть добавлен на любую страницу.

#### Директория /config/

Конфигурационные файлы системы, содержащие настройки подключения к базе данных, управление сессиями и интеграцию с внешними сервисами:

- **database.php**: параметры подключения к MySQL, инициализация PDO
- **session.php**: управление сессиями пользователей, вспомогательные функции
- **headers.php**: настройка HTTP-заголовков для безопасности
- **telegram.php**: настройки и функции для работы с Telegram Bot API

Эти файлы содержат чувствительную информацию и должны быть защищены от прямого доступа извне.

#### Директория /security/

Компоненты, обеспечивающие безопасность системы:

- **security_bootstrap.php**: центральный файл инициализации компонентов безопасности
- **headers.php**: настройка HTTP-заголовков безопасности
- **css.php**, **js.php**, **image.php**, **manifest.php**: файлы для безопасной загрузки ресурсов

Эти компоненты обеспечивают защиту от XSS, CSRF, инъекций и других типов атак.

### Принципы организации

1. **Модульность**: Каждый компонент выполняет определенную функцию и может работать независимо от других.
2. **Разделение логики**: Серверная логика отделена от представления.
3. **Единый стиль**: Общие элементы интерфейса используют единый стиль и поведение.
4. **Безопасность по умолчанию**: Все компоненты разработаны с учетом требований безопасности.
5. **Независимость от устройств**: Все интерфейсы адаптированы для работы на разных устройствах.

### Архитектурные решения

1. **MVC-подобная структура**: Разделение на модели (взаимодействие с данными), представления (интерфейс) и контроллеры (логика).
2. **API-ориентированность**: Большинство операций выполняются через API-запросы.
3. **Многоуровневая безопасность**: Проверки на уровне фронтенда, бэкенда и базы данных.
4. **Реактивное обновление**: Данные обновляются в реальном времени без перезагрузки страницы.

## Файлы конфигурации

Система "ФитоДомик" использует набор конфигурационных файлов для централизованного управления настройками подключения к базе данных, сессиями, HTTP-заголовками и интеграции с внешними сервисами. Эти файлы расположены в директории `/config/` и обеспечивают единую точку настройки различных аспектов системы.

### config/database.php

Этот файл отвечает за установление соединения с базой данных MySQL и настройку параметров работы с ней.

```php
<?php
$host = 'localhost'; 
$dbname = 'название_базы_данных'; 
$username = 'имя_пользователя'; 
$password = 'пароль_пользователя'; 

try {
    // Создаем подключение к базе данных через PDO
    $pdo = new PDO("mysql:host=$host;dbname=$dbname;charset=utf8", $username, $password);
    
    // Настраиваем режим обработки ошибок
    $pdo->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
    
    // Отключаем режим NO_AUTO_VALUE_ON_ZERO для предотвращения создания записей с ID=0
    $pdo->exec("SET SESSION SQL_MODE = 'NO_AUTO_VALUE_ON_ZERO'");
    
} catch(PDOException $e) {
    // Обработка ошибок подключения
    die("Ошибка подключения: " . $e->getMessage());
}
```

#### Ключевые функции и особенности:

1. **PDO-соединение**: Используется PDO (PHP Data Objects) для более безопасного и гибкого взаимодействия с базой данных.
2. **Кодировка UTF-8**: Принудительное использование UTF-8 для корректной работы с кириллицей и другими специальными символами.
3. **Режим отчетов об ошибках**: Настроен на выброс исключений (ERRMODE_EXCEPTION) для более удобной обработки ошибок.
4. **Предотвращение ID=0**: Установка SQL_MODE предотвращает создание записей с ID=0, что может вызвать проблемы в работе системы.
5. **Обработка исключений**: Все ошибки обрабатываются в блоке try-catch для предотвращения утечки информации о структуре базы данных.

### config/session.php

Этот файл управляет сессиями пользователей и предоставляет вспомогательные функции для проверки авторизации и получения данных о текущем пользователе.

```php
<?php
// Запускаем сессию
session_start();
// Подключаем файл заголовков безопасности, если он существует
$headers_file = __DIR__ . '/headers.php';
if (file_exists($headers_file)) {
    require_once $headers_file;
}
/**
 * Проверяет, авторизован ли текущий пользователь
 * @return bool Результат проверки авторизации
 */
function isLoggedIn() {
    return isset($_SESSION['user_id']);
}

/**
 * Возвращает информацию о текущем авторизованном пользователе
 * @return array|null Массив с данными пользователя или null, если пользователь не авторизован
 */
function getCurrentUser() {
    if (isLoggedIn()) {
        return [
            'id' => $_SESSION['user_id'],
            'username' => $_SESSION['username'],
            'first_name' => $_SESSION['first_name'],
            'last_name' => $_SESSION['last_name'],
            'telegram' => $_SESSION['telegram']
        ];
    }
    return null;
}

/**
 * Возвращает приветствие в зависимости от времени суток
 * @return string Текст приветствия
 */
function getGreeting() {
    $hour = date('H');
    if ($hour >= 5 && $hour < 12) {
        return 'Доброе утро';
    } elseif ($hour >= 12 && $hour < 18) {
        return 'Добрый день';
    } else {
        return 'Добрый вечер';
    }
} 
```

#### Ключевые функции и особенности:

1. **Инициализация сессии**: Функция `session_start()` инициализирует или возобновляет текущую сессию.
2. **Интеграция с заголовками безопасности**: Автоматическое подключение файла с заголовками безопасности.
3. **Проверка авторизации**: Функция `isLoggedIn()` проверяет наличие идентификатора пользователя в сессии.
4. **Получение данных пользователя**: Функция `getCurrentUser()` возвращает массив с информацией о текущем пользователе.
5. **Персонализированные приветствия**: Функция `getGreeting()` возвращает приветствие в зависимости от времени суток для более дружественного интерфейса.

### config/telegram.php

Файл содержит настройки и функции для интеграции с Telegram Bot API, что позволяет отправлять уведомления пользователям и получать от них команды через мессенджер Telegram.

```php
<?php
// Определяем константы для работы с Telegram API
define('TELEGRAM_BOT_TOKEN', 'токен_вашего_бота');
define('TELEGRAM_BOT_USERNAME', 'имя_вашего_бота');

/**
 * Отправляет сообщение в Telegram чат
 * @param int|string $chat_id Идентификатор чата
 * @param string $message Текст сообщения
 * @param string $parse_mode Режим форматирования (HTML, Markdown)
 * @return array|false Результат запроса или false в случае ошибки
 */
function sendTelegramMessage($chat_id, $message, $parse_mode = 'HTML') {
    $url = "https://api.telegram.org/bot" . TELEGRAM_BOT_TOKEN . "/sendMessage";
    $data = [
        'chat_id' => $chat_id,
        'text' => $message,
        'parse_mode' => $parse_mode
    ];

    $options = [
        'http' => [
            'method' => 'POST',
            'header' => "Content-Type: application/x-www-form-urlencoded\r\n",
            'content' => http_build_query($data)
        ]
    ];

    $context = stream_context_create($options);
    $result = file_get_contents($url, false, $context);

    return json_decode($result, true);
}

/**
 * Отправляет уведомление о критическом событии пользователю через Telegram
 * @param int $user_id Идентификатор пользователя в системе
 * @param string $message Текст сообщения
 * @return array|false Результат запроса или false в случае ошибки
 */
function sendAlarmNotification($user_id, $message) {
    global $pdo;
    
    try {
        // Получаем chat_id пользователя
        $stmt = $pdo->prepare("SELECT telegram_chat_id FROM users WHERE id = ? AND telegram_chat_id IS NOT NULL");
        $stmt->execute([$user_id]);
        $user = $stmt->fetch(PDO::FETCH_ASSOC);

        if ($user && $user['telegram_chat_id']) {
            // Отправляем уведомление
            return sendTelegramMessage($user['telegram_chat_id'], $message);
        }
        return false;
    } catch (Exception $e) {
        error_log("Error sending Telegram notification: " . $e->getMessage());
        return false;
    }
}
```

#### Ключевые функции и особенности:

1. **Константы для API**: Токен и имя пользователя бота хранятся в константах для удобного использования.
2. **Функция отправки сообщений**: `sendTelegramMessage()` обеспечивает базовый функционал отправки текстовых сообщений.
3. **Поддержка форматирования**: Поддержка HTML и Markdown форматирования для стилизации сообщений.
4. **Функция отправки уведомлений**: `sendAlarmNotification()` автоматически получает идентификатор чата пользователя и отправляет уведомление.
5. **Обработка ошибок**: Все ошибки логируются для последующего анализа и отладки.

### config/headers.php

Файл отвечает за настройку HTTP-заголовков для повышения безопасности и оптимизации кэширования ресурсов в зависимости от их типа.

```php
<?php
/**
 * Файл для установки заголовков безопасности и кэширования
 * Включается в начале каждой страницы сайта
 */

// Устанавливаем заголовок X-Content-Type-Options для защиты от MIME-sniffing
header("X-Content-Type-Options: nosniff");

/**
 * Управляет кэшированием AJAX-запросов
 * @param bool $can_cache Разрешить кэширование
 * @param int $cache_time Время кэширования в секундах
 */
function set_ajax_cache_headers($can_cache = false, $cache_time = 300) {
    // Проверяем, является ли запрос AJAX-запросом
    if (isset($_SERVER['HTTP_X_REQUESTED_WITH']) && 
        strtolower($_SERVER['HTTP_X_REQUESTED_WITH']) === 'xmlhttprequest') {
        
        if ($can_cache) {
            // Если данные можно кэшировать, устанавливаем время кэширования
            header("Cache-Control: private, max-age=$cache_time");
            header("Expires: " . gmdate("D, d M Y H:i:s", time() + $cache_time) . " GMT");
        } else {
            // Если данные нельзя кэшировать, запрещаем кэширование
            header("Cache-Control: no-store, no-cache, must-revalidate, max-age=0");
            header("Pragma: no-cache");
            header("Expires: 0");
        }
    }
}

// Обнаруживаем тип файла по расширению в URL
$request_uri = $_SERVER['REQUEST_URI'];
if (preg_match('/\.([a-zA-Z0-9]+)(?:\?.*)?$/', $request_uri, $matches)) {
    $extension = strtolower($matches[1]);
    
    // Устанавливаем правильный Content-Type и кэширование в зависимости от типа файла
    switch ($extension) {
        // Изображения
        case 'jpg':
        case 'jpeg':
            header("Content-Type: image/jpeg");
            header("Cache-Control: public, max-age=31536000"); // 1 год
            break;
            
        case 'png':
            header("Content-Type: image/png");
            header("Cache-Control: public, max-age=31536000"); // 1 год
            break;
            
        // и другие типы файлов...
    }
}

// Специальные заголовки для API запросов
if (strpos($_SERVER['SCRIPT_NAME'], '/api/') !== false) {
    header("Cache-Control: no-store, no-cache, must-revalidate, max-age=0");
    header("Pragma: no-cache");
    header("Expires: 0");
    header("X-Content-Type-Options: nosniff");
}
```

#### Ключевые функции и особенности:

1. **Защита от MIME-sniffing**: Заголовок X-Content-Type-Options предотвращает неправильное определение типа контента браузером.
2. **Умное кэширование**: Оптимальные настройки кэширования в зависимости от типа файла.
3. **Управление AJAX-кэшированием**: Функция `set_ajax_cache_headers()` позволяет гибко настраивать кэширование AJAX-запросов.
4. **Автоматическое определение типа контента**: Анализ URL для определения типа запрашиваемого файла.
5. **Особые правила для API**: Запрет кэширования для API-запросов для обеспечения актуальности данных.

## Компоненты безопасности

Безопасность является критически важным аспектом системы "ФитоДомик". Для защиты от различных типов атак и угроз в системе реализованы многочисленные компоненты безопасности, расположенные в директории `/security/`.

### security/security_bootstrap.php

Этот файл является центральным компонентом системы безопасности, который инициализирует все необходимые механизмы защиты при загрузке каждой страницы сайта.

```php
<?php
/**
 * Файл для инициализации всех компонентов безопасности
 * Подключается в начале всех PHP-скриптов
 */

// Предварительно удаляем все существующие заголовки X-Content-Type-Options
header_remove("X-Content-Type-Options");

// Устанавливаем заголовки безопасности из headers.php
require_once __DIR__ . '/headers.php';

/**
 * Определяет тип запрашиваемого файла и устанавливает соответствующие заголовки
 */
function add_security_headers() {
    // Определяем тип запрошенного файла по расширению
    $request_uri = $_SERVER['REQUEST_URI'];
    if (preg_match('/\.([a-zA-Z0-9]+)(?:\?.*)?$/', $request_uri, $matches)) {
        $extension = strtolower($matches[1]);
        
        // Добавляем соответствующие заголовки в зависимости от типа файла
        switch ($extension) {
            case 'css':
                header("Content-Type: text/css");
                header("Cache-Control: public, max-age=2592000"); // 30 дней
                break;
                
            case 'js':
                header("Content-Type: application/javascript");
                header("Cache-Control: public, max-age=2592000"); // 30 дней
                break;
            
            // Другие типы файлов...
        }
    }
}

// Добавляем заголовки соответствующие типу файла
add_security_headers();
```

#### Ключевые функции и особенности:

1. **Очистка существующих заголовков**: Предотвращение конфликтов между заголовками.
2. **Подключение общих заголовков безопасности**: Интеграция с файлом headers.php.
3. **Динамическое определение типов контента**: Функция `add_security_headers()` анализирует запрос и устанавливает соответствующие заголовки.
4. **Оптимизация кэширования**: Разные стратегии кэширования для разных типов файлов.
5. **Расширяемость**: Легко добавлять поддержку новых типов файлов и заголовков.

### security/headers.php

Этот файл содержит подробную настройку HTTP-заголовков безопасности, которые защищают от различных типов атак.

```php
<?php
/**
 * Настройка заголовков безопасности HTTP
 */

// Предотвращение clickjacking
header("X-Frame-Options: SAMEORIGIN");

// Защита от XSS
header("X-XSS-Protection: 1; mode=block");

// Предотвращение MIME-sniffing
header("X-Content-Type-Options: nosniff");

// HTTP Strict Transport Security (HSTS)
header("Strict-Transport-Security: max-age=31536000; includeSubDomains; preload");

// Политика безопасности контента (CSP)
$csp = "default-src 'self'; " .
       "script-src 'self' 'unsafe-inline' https://cdnjs.cloudflare.com; " .
       "style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; " .
       "font-src 'self' https://fonts.gstatic.com; " .
       "img-src 'self' data: https://farm429.online; " .
       "connect-src 'self' https://api.telegram.org; " .
       "frame-ancestors 'none';";
header("Content-Security-Policy: " . $csp);

// Политика функций
header("Feature-Policy: camera 'none'; microphone 'none'; geolocation 'none'");

// Политика ссылок
header("Referrer-Policy: strict-origin-when-cross-origin");

// Предотвращение кэширования для страниц, требующих авторизации
if (strpos($_SERVER['SCRIPT_NAME'], '/authentication/') !== false || 
    strpos($_SERVER['SCRIPT_NAME'], '/api/') !== false) {
    header("Cache-Control: no-store, no-cache, must-revalidate, max-age=0");
    header("Pragma: no-cache");
    header("Expires: 0");
}
```

#### Ключевые функции и особенности:

1. **Защита от Clickjacking**: Заголовок X-Frame-Options предотвращает отображение сайта в iframe.
2. **Защита от XSS**: Включение встроенной в браузер защиты от межсайтового скриптинга.
3. **HSTS**: Принудительное использование HTTPS для всех запросов.
4. **CSP (Content Security Policy)**: Строгая настройка источников для загрузки ресурсов, что предотвращает выполнение вредоносного кода.
5. **Feature Policy**: Ограничение доступа к функциям браузера, таким как камера, микрофон и геолокация.
6. **Referrer Policy**: Контроль информации, передаваемой в заголовке Referer при переходах между страницами.
7. **Предотвращение кэширования**: Отключение кэширования для страниц, требующих авторизации, для предотвращения утечки чувствительной информации.

### security/css.php

Этот файл обеспечивает безопасную загрузку CSS-файлов с проверкой прав доступа и защитой от подмены пути.

```php
<?php
/**
 * Безопасная загрузка CSS-файлов
 */

// Проверяем, что передан параметр file
if (!isset($_GET['file'])) {
    header("HTTP/1.1 400 Bad Request");
    exit("File parameter is required");
}

// Получаем путь к файлу и очищаем его от потенциально опасных последовательностей
$file = $_GET['file'];
$file = str_replace('..', '', $file);
$file = str_replace('/', DIRECTORY_SEPARATOR, $file);

// Определяем полный путь к файлу
$filepath = __DIR__ . '/../css/' . $file;

// Проверяем существование файла
if (!file_exists($filepath) || !is_file($filepath)) {
    header("HTTP/1.1 404 Not Found");
    exit("File not found");
}

// Устанавливаем заголовки для CSS
header("Content-Type: text/css");
header("Cache-Control: public, max-age=2592000"); // 30 дней
header("X-Content-Type-Options: nosniff");

// Выводим содержимое файла
readfile($filepath);
exit;
```

#### Ключевые функции и особенности:

1. **Проверка наличия параметра**: Обязательное наличие параметра file в запросе.
2. **Санитизация пути**: Удаление потенциально опасных последовательностей для предотвращения атак через путь к файлу.
3. **Проверка существования файла**: Предотвращение ошибок при попытке загрузки несуществующего файла.
4. **Установка правильных заголовков**: Content-Type и кэширование для оптимальной работы.
5. **Прямая отдача файла**: Использование readfile() для эффективной передачи содержимого.

### security/js.php, security/image.php, security/manifest.php

Эти файлы работают по аналогичному принципу, обеспечивая безопасную загрузку JavaScript-файлов, изображений и манифеста приложения соответственно. Каждый из них выполняет проверку прав доступа, санитизацию пути к файлу и устанавливает соответствующие HTTP-заголовки.

### Дополнительные меры безопасности

Помимо описанных выше компонентов, в системе "ФитоДомик" реализованы следующие меры безопасности:

1. **Защита от SQL-инъекций**:
   - Использование PDO с параметризованными запросами
   - Типизация данных при передаче в запросы
   - Минимальные привилегии для пользователя базы данных

2. **Защита паролей**:
   - Хеширование паролей с использованием bcrypt (password_hash)
   - Соль и перец для дополнительной защиты
   - Минимальные требования к сложности пароля

3. **Защита от CSRF**:
   - Генерация и проверка токенов в формах
   - Проверка заголовка Referer для запросов
   - Проверка Origin для AJAX-запросов

4. **Защита сессий**:
   - Регенерация ID сессии при входе и смене уровня привилегий
   - Хранение сессий в защищенной директории
   - Настройка безопасных cookie (httpOnly, secure)

5. **Защита от DoS-атак**:
   - Ограничение частоты запросов
   - Кэширование часто запрашиваемых данных
   - Защита от перебора паролей (временная блокировка после неудачных попыток)

### Принципы обеспечения безопасности

1. **Эшелонированная защита**: Несколько уровней защиты для каждого ресурса.
2. **Минимальные привилегии**: Предоставление только необходимых прав доступа.
3. **Безопасность по умолчанию**: Все компоненты разработаны с учетом безопасности.
4. **Проактивный мониторинг**: Логирование и анализ попыток несанкционированного доступа.
5. **Регулярные обновления**: Своевременное обновление программного обеспечения и зависимостей.

Эта многоуровневая система безопасности обеспечивает надежную защиту данных пользователей и устройств, подключенных к системе "ФитоДомик".

## Система аутентификации

Система аутентификации в "ФитоДомик" реализует надежную многоуровневую проверку пользователей с верификацией через Telegram для обеспечения дополнительной безопасности. Все компоненты системы аутентификации расположены в директории `/authentication/` и обеспечивают полный цикл регистрации, верификации, авторизации и управления пользовательскими аккаунтами.

### Процесс регистрации и верификации

Регистрация пользователя в системе "ФитоДомик" происходит в два этапа:

1. **Базовая регистрация**: Пользователь заполняет форму с личными данными (имя, фамилия, никнейм, пароль).
2. **Верификация через Telegram**: Для подтверждения личности пользователь должен пройти дополнительную верификацию через Telegram бота.

Этот двухэтапный подход обеспечивает повышенную безопасность и позволяет в дальнейшем использовать Telegram для отправки важных уведомлений о состоянии фермы.

### authentication/register.php

Файл отвечает за первый этап регистрации - сбор основных данных пользователя и их валидацию.

```php
<?php
require_once '../config/database.php';
require_once '../config/session.php';
require_once '../config/headers.php';

// Перенаправление на главную, если пользователь уже авторизован
if (isLoggedIn()) {
    header("Location: ../index.php");
    exit();
}

$errors = [];

// Обработка отправки формы
if ($_SERVER['REQUEST_METHOD'] === 'POST') {
    // Получение данных из формы
    $first_name = $_POST['first_name'] ?? '';
    $last_name = $_POST['last_name'] ?? '';
    $username = $_POST['username'] ?? '';
    $password = $_POST['password'] ?? '';
    $confirm_password = $_POST['confirm_password'] ?? '';

    // Валидация данных
    if (empty($first_name)) $errors[] = "Имя обязательно для заполнения";
    if (empty($last_name)) $errors[] = "Фамилия обязательна для заполнения";
    if (empty($username)) $errors[] = "Никнейм обязателен для заполнения";
    if (empty($password)) $errors[] = "Пароль обязателен для заполнения";
    if ($password !== $confirm_password) $errors[] = "Пароли не совпадают";

    // Проверка формата никнейма
    if (!empty($username) && !preg_match('/^[a-zA-Z0-9_]{3,20}$/', $username)) {
        $errors[] = "Никнейм должен содержать только латинские буквы, цифры и знак подчеркивания, длина от 3 до 20 символов";
    }

    // Если ошибок нет, проверяем уникальность никнейма
    if (empty($errors)) {
        $stmt = $pdo->prepare("SELECT id FROM users WHERE username = ?");
        $stmt->execute([$username]);
        if ($stmt->fetch()) {
            $errors[] = "Этот никнейм уже занят";
        } else {
            // Проверяем наличие верификации для этого никнейма
            $stmt = $pdo->prepare("SELECT id FROM telegram_verifications WHERE username = ?");
            $stmt->execute([$username]);
            if ($stmt->fetch()) {
                $errors[] = "Этот никнейм уже зарегистрирован в системе верификации. Пожалуйста, выберите другой.";
            } else {
                // Сохраняем данные пользователя во временную сессию
                $_SESSION['temp_user'] = [
                    'first_name' => $first_name,
                    'last_name' => $last_name,
                    'username' => $username,
                    'password' => password_hash($password, PASSWORD_DEFAULT)
                ];
                // Перенаправляем на страницу верификации через Telegram
                header("Location: telegram_verify.php");
                exit();
            }
        }
    }
}

// Функция для транслитерации кириллических символов
function transliterate($string) {
    $converter = array(
        'а' => 'a',    'б' => 'b',    'в' => 'v',    'г' => 'g',    'д' => 'd',
        'е' => 'e',    'ё' => 'e',    'ж' => 'zh',   'з' => 'z',    'и' => 'i',
        // ... другие символы ...
    );
    $string = strtr($string, $converter);
    $string = strtolower($string);
    $string = preg_replace('/[^-a-z0-9_]+/', '', $string);
    $string = trim($string, '-');
    return $string;
}
?>
<!DOCTYPE html>
<html lang="ru" data-theme="light">
<head>
    <!-- Метаданные страницы -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Регистрация - ФитоДомик</title>
    
    <!-- SEO метатеги -->
    <meta name="description" content="Регистрация в системе управления умной фермой ФитоДомик. Создайте аккаунт для доступа к полному функционалу управления вашей умной фермой.">
    <!-- ... другие метатеги ... -->
    
    <!-- Стили и скрипты -->
    <link rel="stylesheet" href="../css/styles.css">
    <!-- ... другие ресурсы ... -->
</head>
<body>
    <div class="auth-container">
        <!-- Кнопка переключения темы -->
        <button id="theme-toggle" class="theme-toggle auth-theme-toggle">
            <span class="theme-icon">🌙</span>
        </button>
        
        <div class="auth-form">
            <h2>Регистрация в ФитоДомик</h2>
            
            <!-- Отображение ошибок валидации -->
            <?php if (!empty($errors)): ?>
                <div class="error-message">
                    <ul>
                        <?php foreach ($errors as $error): ?>
                            <li><?php echo htmlspecialchars($error); ?></li>
                        <?php endforeach; ?>
                    </ul>
                </div>
            <?php endif; ?>
            
            <!-- Форма регистрации -->
            <form method="POST" action="">
                <!-- Поля формы: имя, фамилия, никнейм, пароль и подтверждение пароля -->
                <div class="form-group">
                    <label for="first_name">Имя</label>
                    <input type="text" id="first_name" name="first_name" value="<?php echo htmlspecialchars($_POST['first_name'] ?? ''); ?>" required>
                </div>
                <!-- ... другие поля ... -->
                
                <!-- Кнопки формы -->
                <div class="profile-actions">
                    <button type="submit" class="auth-button">Продолжить регистрацию</button>
                    <a href="login.php" class="auth-button secondary">Уже есть аккаунт? Войти</a>
                    <a href="../index.php" class="auth-button secondary return-profile">Вернуться на главную</a>
                </div>
            </form>
        </div>
    </div>
    
    <!-- Подключение скрипта для управления темой -->
    <script src="js/theme.js"></script>
</body>
</html>
```

#### Ключевые функции и особенности страницы регистрации:

1. **Проверка авторизации**: Авторизованные пользователи перенаправляются на главную страницу.
2. **Валидация данных формы**: Проверка заполнения обязательных полей и формата никнейма.
3. **Проверка уникальности никнейма**: Предотвращение дублирования имен пользователей.
4. **Хеширование пароля**: Безопасное хранение пароля с использованием функции password_hash.
5. **Временное хранение данных**: Сохранение данных пользователя в сессии до завершения верификации.
6. **Поддержка транслитерации**: Функция для преобразования кириллических символов в латинские.
7. **SEO-оптимизация**: Метатеги для лучшей индексации страницы.
8. **Адаптивный дизайн**: Корректное отображение на различных устройствах.
9. **Поддержка темизации**: Возможность переключения между светлой и темной темами.

### authentication/telegram_verify.php

Этот файл отвечает за второй этап регистрации - верификацию пользователя через Telegram бота. Страница отображает инструкции для пользователя и периодически опрашивает сервер для проверки статуса верификации.

```php
<?php
require_once '../config/database.php';
require_once '../config/session.php';
require_once '../config/telegram.php';
require_once '../config/headers.php';

// Проверяем наличие временных данных
if (!isset($_SESSION['temp_user'])) {
    header("Location: register.php");
    exit;
}

$temp_user = $_SESSION['temp_user'];
$bot_username = TELEGRAM_BOT_USERNAME;
?>
<!DOCTYPE html>
<html lang="ru" data-theme="light">
<head>
    <!-- Метаданные страницы -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Верификация Telegram - ФитоДомик</title>
    <link rel="stylesheet" href="../css/styles.css">
    
    <!-- Иконки -->
    <link rel="apple-touch-icon" sizes="180x180" href="../icon/apple-touch-icon.png">
    <!-- ... другие иконки ... -->
</head>
<body>
    <div class="auth-container">
        <!-- Кнопка переключения темы -->
        <button id="theme-toggle" class="theme-toggle auth-theme-toggle">
            <span class="theme-icon">🌙</span>
        </button>
        
        <div class="auth-form">
            <h2>Верификация через Telegram</h2>
            
            <!-- Инструкция по верификации -->
            <div class="verification-info">
                <h4>Инструкция по верификации:</h4>
                <ol>
                    <li>Перейдите в Telegram бот: <a href="https://t.me/<?php echo htmlspecialchars($bot_username); ?>" target="_blank">@<?php echo htmlspecialchars($bot_username); ?></a></li>
                    <li>Отправьте команду /start</li>
                    <li>Введите ваш никнейм: <strong><?php echo htmlspecialchars($temp_user['username']); ?></strong></li>
                    <li>Дождитесь подтверждения верификации</li>
                </ol>
            </div>
            
            <!-- Кнопка для перехода в Telegram -->
            <div class="text-center">
                <a href="https://t.me/<?php echo htmlspecialchars($bot_username); ?>" class="auth-button" target="_blank">
                    Перейти в Telegram бот
                </a>
            </div>
            
            <!-- Статус верификации -->
            <div class="mt-3 text-center">
                <p>После верификации вы будете перенаправлены на главную страницу.</p>
                <div id="verification-status"></div>
            </div>
            
            <!-- Кнопки навигации -->
            <div class="profile-actions">
                <a href="register.php" class="auth-button secondary">Вернуться к регистрации</a>
                <a href="../index.php" class="auth-button secondary return-profile">Вернуться на главную</a>
            </div>
        </div>
    </div>
    
    <!-- Скрипт для проверки статуса верификации -->
    <script>
        // Счетчик проверок и элемент для отображения статуса
        let checkCount = 0;
        const statusDiv = document.getElementById('verification-status');
        
        // Функция для периодической проверки статуса верификации
        function checkVerificationStatus() {
            checkCount++;
            statusDiv.innerHTML = '<div>Проверка #' + checkCount + ' для пользователя <?php echo htmlspecialchars($temp_user['username']); ?> (' + new Date().toLocaleTimeString() + ')</div>';
            
            // Отправляем запрос на сервер для проверки статуса
            fetch('../api/check_verification.php')
                .then(response => response.json())
                .then(data => {
                    console.log('Ответ от сервера:', data);
                    if (data.verified) {
                        // Если верификация успешна
                        statusDiv.innerHTML = 
                            '<div class="success-message">Верификация успешно завершена!</div>';
                        setTimeout(() => {
                            window.location.href = '../index.php';
                        }, 2000);
                    } else {
                        // Если верификация еще не завершена
                        statusDiv.innerHTML += '<div>Ожидание верификации... (' + data.message + ')</div>';
                        setTimeout(checkVerificationStatus, 5000);
                    }
                })
                .catch(error => {
                    console.error('Ошибка:', error);
                    statusDiv.innerHTML += '<div>Ошибка при проверке верификации</div>';
                    setTimeout(checkVerificationStatus, 5000);
                });
        }

        // Запускаем проверку статуса при загрузке страницы
        checkVerificationStatus();
    </script>
    
    <!-- Подключение скрипта для управления темой -->
    <script src="js/theme.js"></script>
</body>
</html>
```

#### Ключевые функции и особенности страницы верификации:

1. **Проверка наличия временных данных**: Перенаправление на страницу регистрации, если данные отсутствуют.
2. **Понятные инструкции**: Пошаговое руководство по верификации с выделением никнейма.
3. **Прямая ссылка на бота**: Кнопка для быстрого перехода в Telegram.
4. **Периодическая проверка статуса**: AJAX-запросы для проверки статуса верификации каждые 5 секунд.
5. **Визуальная обратная связь**: Отображение текущего статуса и количества выполненных проверок.
6. **Автоматическое перенаправление**: Переход на главную страницу после успешной верификации.
7. **Обработка ошибок**: Корректная обработка сетевых ошибок и проблем с сервером.
8. **Альтернативные пути**: Возможность вернуться к регистрации или на главную страницу.

### api/check_verification.php

Этот API-эндпоинт проверяет статус верификации пользователя в таблице `telegram_verifications` и, при успешной верификации, создает учетную запись пользователя.

```php
<?php
require_once '../config/database.php';
require_once '../config/session.php';

header('Content-Type: application/json');

// Функция для логирования событий
$log_file = $_SERVER['DOCUMENT_ROOT'] . '/logs/verification_log.txt';
function log_message($message) {
    global $log_file;
    file_put_contents($log_file, date('Y-m-d H:i:s') . " - " . $message . "\n", FILE_APPEND);
}

log_message("Начало проверки верификации");

// Проверяем наличие временных данных пользователя
if (!isset($_SESSION['temp_user'])) {
    log_message("Ошибка: временные данные пользователя не найдены");
    echo json_encode(['verified' => false, 'message' => 'Временные данные пользователя не найдены']);
    exit;
}

// Получаем никнейм пользователя из временных данных
$temp_user = $_SESSION['temp_user'];
$username = $temp_user['username'];
log_message("Проверка верификации для пользователя: " . $username);

try {
    // Проверяем существование таблицы telegram_verifications
    $checkTable = $pdo->query("SHOW TABLES LIKE 'telegram_verifications'");
    if ($checkTable->rowCount() == 0) {
        log_message("Таблица telegram_verifications не существует");
        echo json_encode(['verified' => false, 'message' => 'Таблица верификации не существует']);
        exit;
    }
    
    // Проверяем, есть ли запись о верификации в таблице telegram_verifications
    $stmt = $pdo->prepare("SELECT * FROM telegram_verifications WHERE username = ?");
    $stmt->execute([$username]);
    $verification = $stmt->fetch(PDO::FETCH_ASSOC);
    
    log_message("Результат запроса верификации: " . ($verification ? "Найдена запись" : "Запись не найдена"));
    
    if ($verification) {
        log_message("Верификация найдена: " . json_encode($verification));
        
        // Проверяем, не существует ли уже пользователь с таким именем
        $checkUser = $pdo->prepare("SELECT id FROM users WHERE username = ?");
        $checkUser->execute([$username]);
        if ($checkUser->fetch()) {
            log_message("Ошибка: пользователь с таким именем уже существует");
            echo json_encode(['verified' => false, 'message' => 'Пользователь с таким именем уже существует']);
            exit;
        }
        
        // Используем ID из верификации для создания пользователя
        $userId = $verification['id'];
        log_message("Используем ID из верификации: " . $userId);
        
        // Создаем учетную запись пользователя
        try {
            $insertQuery = "INSERT INTO users (id, username, password, first_name, last_name, telegram_username, telegram_chat_id, is_verified) 
                         VALUES (?, ?, ?, ?, ?, ?, ?, 1)";
            log_message("Выполняем запрос: " . $insertQuery);
            
            $stmt = $pdo->prepare($insertQuery);
            $result = $stmt->execute([
                $userId,
                $temp_user['username'],
                $temp_user['password'],
                $temp_user['first_name'],
                $temp_user['last_name'],
                $verification['telegram_username'],
                $verification['telegram_chat_id']
            ]);
            
            if (!$result) {
                log_message("Ошибка выполнения запроса: " . json_encode($stmt->errorInfo()));
                echo json_encode(['verified' => false, 'message' => 'Ошибка создания пользователя']);
                exit;
            }
            
            log_message("Создан новый пользователь с ID: " . $userId);
            
            // Сохраняем данные в сессию для автоматической авторизации
            $_SESSION['user_id'] = $userId;
            $_SESSION['username'] = $temp_user['username'];
            $_SESSION['first_name'] = $temp_user['first_name'];
            $_SESSION['last_name'] = $temp_user['last_name'];
            $_SESSION['telegram'] = $verification['telegram_username'];
            
            // Очищаем временные данные
            unset($_SESSION['temp_user']);
            log_message("Временные данные очищены, пользователь авторизован");
            
            echo json_encode(['verified' => true, 'message' => 'Верификация успешна']);
            
        } catch (PDOException $e) {
            // Обработка ошибок при создании пользователя
            // ... код обработки ошибок ...
        }
    } else {
        // Верификация еще не пройдена
        log_message("Верификация не найдена для пользователя " . $username);
        echo json_encode(['verified' => false, 'message' => 'Ожидается верификация через Telegram']);
    }
} catch (PDOException $e) {
    // Обработка ошибок PDO
    log_message("Ошибка PDO: " . $e->getMessage());
    echo json_encode(['verified' => false, 'message' => 'Ошибка верификации: ' . $e->getMessage()]);
}
```

#### Ключевые функции и особенности эндпоинта проверки верификации:

1. **Логирование всех действий**: Подробная запись каждого шага для отладки.
2. **Проверка наличия данных**: Валидация наличия временных данных пользователя.
3. **Проверка структуры базы данных**: Убеждаемся, что необходимая таблица существует.
4. **Поиск записи верификации**: Поиск подтверждения верификации по никнейму.
5. **Проверка уникальности пользователя**: Предотвращение дублирования пользователей.
6. **Синхронизация ID**: Использование одинакового ID для записей в разных таблицах.
7. **Создание пользователя**: Вставка данных пользователя в таблицу users.
8. **Автоматическая авторизация**: Создание сессии для нового пользователя.
9. **Обработка ошибок**: Детальная обработка различных типов ошибок.
10. **JSON-ответ**: Структурированный ответ с информацией о статусе верификации.

### api/telegram_webhook.php

Этот API-эндпоинт обрабатывает запросы от Telegram API, проверяет введенный пользователем никнейм и создает запись в таблице верификации. Этот файл является серверной частью верификации через Telegram.

## API и взаимодействие с устройствами

Система "ФитоДомик" реализует расширенный API для взаимодействия с физическими устройствами умной фермы и управления режимами выращивания. Все API-эндпоинты используют единый подход к авторизации, обработке данных и форматированию ответов.

### Авторизация API-запросов

Все API-эндпоинты защищены и требуют авторизации. Поддерживаются два метода авторизации:

1. **Авторизация по сессии**: Для запросов с веб-интерфейса, когда пользователь уже авторизован.
2. **Авторизация по API-токену**: Для запросов от внешних клиентов (мобильные приложения, устройства).

Пример проверки авторизации в API-эндпоинте:

```php
// Проверка авторизации пользователя
if (isset($_SESSION['user_id'])) {
    $user_id = $_SESSION['user_id'];
} elseif (isset($_POST['api_token']) || isset($_GET['api_token'])) {
    $token = $_POST['api_token'] ?? $_GET['api_token'];
    
    $stmt = $pdo->prepare("SELECT id FROM users WHERE api_token = ?");
    $stmt->execute([$token]);
    $user = $stmt->fetch(PDO::FETCH_ASSOC);
    
    if (!$user) {
        http_response_code(401);
        echo json_encode(['error' => 'Неверный API-токен']);
        exit;
    }
    
    $user_id = $user['id'];
} else {
    http_response_code(401);
    echo json_encode(['error' => 'Требуется авторизация']);
    exit;
}
```

### Ключевые группы API-эндпоинтов

#### 1. Получение данных с датчиков

Эндпоинты для получения текущих и исторических данных с датчиков умной фермы.

- **get-sensor-data.php**: Получение данных с датчиков за определенный период
- **get-farm-status.php**: Получение текущего статуса фермы
- **get-thresholds.php**: Получение пороговых значений для датчиков

#### 2. Управление устройствами

Эндпоинты для управления физическими устройствами умной фермы.

- **toggle-lamp.php**: Включение/выключение освещения
- **toggle-curtains.php**: Открытие/закрытие штор
- **set-curtains-state.php**: Установка конкретного состояния штор

#### 3. Управление режимами выращивания

Эндпоинты для создания, редактирования и активации режимов выращивания.

- **save-preset-mode.php**: Сохранение нового режима выращивания
- **share-preset-mode.php**: Создание общедоступного режима
- **activate-preset-mode.php**: Активация выбранного режима

#### 4. Настройка параметров

Эндпоинты для настройки параметров автоматизации и пороговых значений.

- **save-limits.php**: Сохранение пороговых значений для датчиков
- **save-temperature.php**: Настройка параметров температуры
- **save-humidity.php**: Настройка параметров влажности
- **save-lighting.php**: Настройка параметров освещения

### Формат ответов API

Все API-эндпоинты возвращают данные в формате JSON с единой структурой:

```json
{
    "success": true,
    "data": {
        "key1": "value1",
        "key2": "value2"
    },
    "message": "Операция успешно выполнена"
}
```

В случае ошибки:

```json
{
    "success": false,
    "error": "Описание ошибки",
    "code": 404
}
```

### Пример API-эндпоинта: toggle-lamp.php

Этот эндпоинт переключает состояние освещения (включено/выключено) и сохраняет новое состояние в базе данных.

```php
<?php
require_once '../config/database.php';
require_once '../config/session.php';

header('Content-Type: application/json');

// Проверка авторизации
if (isset($_SESSION['user_id'])) {
    $user_id = $_SESSION['user_id'];
} elseif (isset($_POST['api_token']) || isset($_GET['api_token'])) {
    $token = $_POST['api_token'] ?? $_GET['api_token'];
    
    $stmt = $pdo->prepare("SELECT id FROM users WHERE api_token = ?");
    $stmt->execute([$token]);
    $user = $stmt->fetch(PDO::FETCH_ASSOC);
    
    if (!$user) {
        echo json_encode(['success' => false, 'error' => 'Неверный API-токен']);
        exit;
    }
    
    $user_id = $user['id'];
} else {
    echo json_encode(['success' => false, 'error' => 'Требуется авторизация']);
    exit;
}

// Получаем текущее состояние лампы
$stmt = $pdo->prepare("
    SELECT lamp_state 
    FROM sensor_data 
    WHERE user_id = ? 
    ORDER BY created_at DESC 
    LIMIT 1
");
$stmt->execute([$user_id]);
$current_state = $stmt->fetch(PDO::FETCH_ASSOC);

// Если данных нет, устанавливаем дефолтное значение
if (!$current_state) {
    $new_state = 1; // Включено
} else {
    // Инвертируем текущее состояние
    $new_state = $current_state['lamp_state'] ? 0 : 1;
}

// Получаем последние данные с датчиков для сохранения
$stmt = $pdo->prepare("
    SELECT temperature, humidity, soil_moisture, light_level, curtains_state
    FROM sensor_data 
    WHERE user_id = ? 
    ORDER BY created_at DESC 
    LIMIT 1
");
$stmt->execute([$user_id]);
$last_data = $stmt->fetch(PDO::FETCH_ASSOC);

if ($last_data) {
    // Сохраняем новое состояние лампы с сохранением других данных
    $stmt = $pdo->prepare("
        INSERT INTO sensor_data 
        (user_id, temperature, humidity, soil_moisture, light_level, lamp_state, curtains_state)
        VALUES (?, ?, ?, ?, ?, ?, ?)
    ");
    $stmt->execute([
        $user_id,
        $last_data['temperature'],
        $last_data['humidity'],
        $last_data['soil_moisture'],
        $last_data['light_level'],
        $new_state,
        $last_data['curtains_state']
    ]);
} else {
    // Если данных нет, создаем запись только с состоянием лампы
    $stmt = $pdo->prepare("
        INSERT INTO sensor_data 
        (user_id, lamp_state)
        VALUES (?, ?)
    ");
    $stmt->execute([$user_id, $new_state]);
}

// Получаем обновленное состояние для возврата
$state_text = $new_state ? 'включена' : 'выключена';

// Возвращаем результат
echo json_encode([
    'success' => true,
    'data' => [
        'lamp_state' => $new_state,
        'state_text' => $state_text
    ],
    'message' => 'Состояние лампы изменено. Лампа ' . $state_text
]);
```

### Получение API-токена

Для получения API-токена пользователь должен авторизоваться в системе и перейти на страницу `get_token.php`, где отображается его персональный токен и инструкции по его использованию.

## Основные страницы и компоненты

### index.php: Главная страница

Главная страница системы объединяет все основные компоненты управления умной фермой. Её структура модульная, что позволяет легко добавлять или изменять функциональные блоки.

#### Ключевые функции главной страницы:

1. **Проверка авторизации**: Доступ к различным функциям зависит от статуса авторизации.
2. **Модульная загрузка компонентов**: Динамическая загрузка компонентов из директории `/components/`.
3. **Адаптивный дизайн**: Оптимизация интерфейса для разных устройств.
4. **Интерактивное управление**: Элементы управления устройствами умной фермы.
5. **Визуализация данных**: Графики и диаграммы для отображения показателей.

### Основные компоненты

#### farm-status.php

Отображает текущее состояние умной фермы:
- Температура
- Влажность воздуха
- Влажность почвы
- Уровень освещенности
- Состояние устройств (лампы, шторы)

#### farm-graphs.php

Визуализирует исторические данные с датчиков в виде графиков:
- Динамика изменения показателей во времени
- Сравнение разных периодов
- Анализ тенденций

#### alarm-thresholds.php

Позволяет настроить пороговые значения для автоматизации и оповещений:
- Минимальная и максимальная температура
- Минимальная и максимальная влажность
- Уровень освещенности
- Настройка действий при превышении порогов

#### preset-modes.php

Управление предустановленными режимами выращивания:
- Создание новых режимов
- Активация существующих режимов
- Копирование и редактирование режимов
- Совместное использование режимов с другими пользователями

#### planting-calendar.php

Планирование и отслеживание активностей по выращиванию:
- Добавление событий (посадка, полив, сбор урожая)
- Календарное представление
- Уведомления о запланированных действиях

## SEO-оптимизация

Система "ФитоДомик" оптимизирована для лучшей индексации поисковыми системами и корректного отображения в социальных сетях.

### sitemap.xml

Файл карты сайта содержит информацию о структуре сайта для поисковых систем:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
    <url>
        <loc>https://example.com/</loc>
        <lastmod>ГГГГ-ММ-ДД</lastmod>
        <changefreq>daily</changefreq>
        <priority>1.0</priority>
    </url>
    <url>
        <loc>https://example.com/index.php</loc>
        <lastmod>ГГГГ-ММ-ДД</lastmod>
        <changefreq>daily</changefreq>
        <priority>1.0</priority>
    </url>
    <!-- Другие страницы -->
</urlset>
```

### robots.txt

Файл инструкций для поисковых роботов:

```
User-agent: *
Allow: /
Disallow: /authentication/
Disallow: /api/
Disallow: /config/
Disallow: /uploads/

Sitemap: https://example.com/sitemap.xml
```

### Мета-теги и структурированные данные

Каждая страница включает:

1. **Основные мета-теги**:
   ```html
   <meta name="description" content="Описание страницы">
   <meta name="keywords" content="ключевые, слова">
   <meta name="robots" content="index, follow">
   ```

2. **Open Graph для социальных сетей**:
   ```html
   <meta property="og:title" content="Заголовок">
   <meta property="og:description" content="Описание">
   <meta property="og:image" content="URL изображения">
   ```

3. **Schema.org разметка**:
   ```html
   <script type="application/ld+json">
   {
       "@context": "https://schema.org",
       "@type": "WebApplication",
       "name": "ФитоДомик",
       "description": "Система управления умной фермой"
   }
   </script>
   ```

## Система темизации

Система "ФитоДомик" поддерживает переключение между светлой и темной темами для лучшего пользовательского опыта.

### CSS-переменные

Темы реализованы через CSS-переменные:

```css
:root {
    --primary-color: #2E7D32;
    --primary-light: #4CAF50;
    --primary-dark: #1B5E20;
    --text-color: #333;
    --bg-color: #f5f5f5;
    --card-bg: white;
    --shadow-color: rgba(0,0,0,0.1);
    --border-color: #e0e0e0;
}

[data-theme="dark"] {
    --primary-color: #4CAF50;
    --primary-light: #66BB6A;
    --primary-dark: #2E7D32;
    --text-color: #f5f5f5;
    --bg-color: #1a1a1a;
    --card-bg: #2d2d2d;
    --shadow-color: rgba(0,0,0,0.3);
    --border-color: #404040;
}
```

### JavaScript для переключения тем

```javascript
// Функция для переключения темы
function toggleTheme() {
    const html = document.documentElement;
    const currentTheme = html.getAttribute('data-theme');
    const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
    
    // Устанавливаем новую тему
    html.setAttribute('data-theme', newTheme);
    localStorage.setItem('theme', newTheme);
    
    // Обновляем иконку
    const themeIcon = document.querySelector('.theme-icon');
    if (themeIcon) {
        themeIcon.textContent = newTheme === 'light' ? '🌙' : '☀️';
    }
}

// Загрузка сохраненной темы при загрузке страницы
document.addEventListener('DOMContentLoaded', function() {
    const savedTheme = localStorage.getItem('theme') || 'light';
    document.documentElement.setAttribute('data-theme', savedTheme);
    
    const themeIcon = document.querySelector('.theme-icon');
    if (themeIcon) {
        themeIcon.textContent = savedTheme === 'dark' ? '☀️' : '🌙';
    }
});
```

## Система логирования

Система "ФитоДомик" использует подробное логирование для отслеживания действий пользователей и диагностики проблем.

### Основные лог-файлы

- `/logs/verification_log.txt`: Записи о процессе верификации пользователей
- `/logs/telegram_webhook.log`: Логи взаимодействия с Telegram API
- `/logs/api_errors.log`: Ошибки в работе API

### Функция логирования

```php
/**
 * Записывает сообщение в лог-файл
 * @param string $message Текст сообщения
 * @param string $logFile Путь к лог-файлу
 */
function log_message($message, $logFile = null) {
    if (!$logFile) {
        $logFile = $_SERVER['DOCUMENT_ROOT'] . '/logs/app.log';
    }
    
    $timestamp = date('Y-m-d H:i:s');
    $logEntry = "[$timestamp] $message" . PHP_EOL;
    
    file_put_contents($logFile, $logEntry, FILE_APPEND);
}
```

## Структура базы данных

Система "ФитоДомик" использует реляционную базу данных MySQL для хранения данных пользователей, показаний датчиков и настроек.

### Основные таблицы

#### users

Хранит информацию о пользователях системы:

| Поле | Тип | Описание |
|------|-----|----------|
| id | INT | Уникальный идентификатор |
| username | VARCHAR(255) | Имя пользователя |
| password | VARCHAR(255) | Хешированный пароль |
| first_name | VARCHAR(255) | Имя |
| last_name | VARCHAR(255) | Фамилия |
| telegram_username | VARCHAR(255) | Имя пользователя в Telegram |
| telegram_chat_id | VARCHAR(255) | ID чата в Telegram |
| api_token | VARCHAR(255) | Токен для API-запросов |
| is_verified | TINYINT | Статус верификации |
| created_at | TIMESTAMP | Дата создания |

#### telegram_verifications

Хранит данные о верификации пользователей через Telegram:

| Поле | Тип | Описание |
|------|-----|----------|
| id | INT | Уникальный идентификатор |
| username | VARCHAR(255) | Имя пользователя |
| telegram_username | VARCHAR(255) | Имя в Telegram |
| telegram_chat_id | VARCHAR(255) | ID чата в Telegram |
| is_verified | TINYINT | Статус верификации |
| created_at | TIMESTAMP | Дата создания |

#### sensor_data

Хранит данные, полученные с датчиков умной фермы:

| Поле | Тип | Описание |
|------|-----|----------|
| id | INT | Уникальный идентификатор |
| user_id | INT | ID пользователя |
| temperature | FLOAT | Температура |
| humidity | FLOAT | Влажность воздуха |
| soil_moisture | FLOAT | Влажность почвы |
| light_level | INT | Уровень освещенности |
| lamp_state | TINYINT | Состояние лампы |
| curtains_state | TINYINT | Состояние штор |
| created_at | TIMESTAMP | Время записи |

#### thresholds

Хранит пороговые значения для автоматизации:

| Поле | Тип | Описание |
|------|-----|----------|
| id | INT | Уникальный идентификатор |
| user_id | INT | ID пользователя |
| min_temperature | FLOAT | Мин. температура |
| max_temperature | FLOAT | Макс. температура |
| min_humidity | FLOAT | Мин. влажность |
| max_humidity | FLOAT | Макс. влажность |
| min_soil_moisture | FLOAT | Мин. влажность почвы |
| min_light_level | INT | Мин. освещенность |
| max_light_level | INT | Макс. освещенность |
| updated_at | TIMESTAMP | Время обновления |

#### preset_modes

Хранит предустановленные режимы выращивания:

| Поле | Тип | Описание |
|------|-----|----------|
| id | INT | Уникальный идентификатор |
| user_id | INT | ID пользователя |
| name | VARCHAR(255) | Название режима |
| description | TEXT | Описание режима |
| temperature | FLOAT | Целевая температура |
| humidity | FLOAT | Целевая влажность |
| soil_moisture | FLOAT | Целевая влажность почвы |
| light_level | INT | Целевой уровень освещенности |
| is_active | TINYINT | Активен ли режим |
| is_public | TINYINT | Публичный ли режим |
| created_at | TIMESTAMP | Время создания |

#### planting_events

Хранит события календаря посадок:

| Поле | Тип | Описание |
|------|-----|----------|
| id | INT | Уникальный идентификатор |
| user_id | INT | ID пользователя |
| plant_name | VARCHAR(255) | Название растения |
| event_type | VARCHAR(50) | Тип события |
| event_date | DATE | Дата события |
| notes | TEXT | Заметки |
| created_at | TIMESTAMP | Время создания |

### Связи между таблицами

1. `users.id` → `sensor_data.user_id`: данные датчиков принадлежат конкретному пользователю
2. `users.id` → `thresholds.user_id`: настройки порогов принадлежат конкретному пользователю
3. `users.id` → `preset_modes.user_id`: режимы выращивания принадлежат конкретному пользователю
4. `users.id` → `planting_events.user_id`: события календаря принадлежат конкретному пользователю
5. `users.username` → `telegram_verifications.username`: связь между верификацией и пользователем

### Индексы и оптимизация

1. **Первичные ключи**: Все таблицы имеют первичный ключ `id`
2. **Индексы для внешних ключей**: Для ускорения JOIN-запросов
3. **Индексы для часто запрашиваемых полей**: `username`, `api_token`
4. **Составные индексы**: Для часто используемых комбинаций полей в WHERE
5. **Индексы по времени**: Для запросов с фильтрацией по `created_at`

---

Эта документация предоставляет подробное описание структуры и функциональности системы управления умной фермой "ФитоДомик". Она поможет разработчикам быстро разобраться в архитектуре проекта и начать работу над его расширением или модификацией. 
